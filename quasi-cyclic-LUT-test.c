#include <stdio.h>
#include <stdint.h>

// Parity table for the quasi-cyclic code. Used to look up the parity byte from the data byte,
// both during encoding (from the original data byte) and decoding (from the received data byte).
static const uint8_t P[256] = {
0x00, 0xB2, 0x65, 0xD7, 0xCA, 0x78, 0xAF, 0x1D, 0x95, 0x27, 0xF0, 0x42, 0x5F, 0xED, 0x3A, 0x88,
0x2B, 0x99, 0x4E, 0xFC, 0xE1, 0x53, 0x84, 0x36, 0xBE, 0x0C, 0xDB, 0x69, 0x74, 0xC6, 0x11, 0xA3,
0x56, 0xE4, 0x33, 0x81, 0x9C, 0x2E, 0xF9, 0x4B, 0xC3, 0x71, 0xA6, 0x14, 0x09, 0xBB, 0x6C, 0xDE,
0x7D, 0xCF, 0x18, 0xAA, 0xB7, 0x05, 0xD2, 0x60, 0xE8, 0x5A, 0x8D, 0x3F, 0x22, 0x90, 0x47, 0xF5,
0xAC, 0x1E, 0xC9, 0x7B, 0x66, 0xD4, 0x03, 0xB1, 0x39, 0x8B, 0x5C, 0xEE, 0xF3, 0x41, 0x96, 0x24,
0x87, 0x35, 0xE2, 0x50, 0x4D, 0xFF, 0x28, 0x9A, 0x12, 0xA0, 0x77, 0xC5, 0xD8, 0x6A, 0xBD, 0x0F,
0xFA, 0x48, 0x9F, 0x2D, 0x30, 0x82, 0x55, 0xE7, 0x6F, 0xDD, 0x0A, 0xB8, 0xA5, 0x17, 0xC0, 0x72,
0xD1, 0x63, 0xB4, 0x06, 0x1B, 0xA9, 0x7E, 0xCC, 0x44, 0xF6, 0x21, 0x93, 0x8E, 0x3C, 0xEB, 0x59,
0x59, 0xEB, 0x3C, 0x8E, 0x93, 0x21, 0xF6, 0x44, 0xCC, 0x7E, 0xA9, 0x1B, 0x06, 0xB4, 0x63, 0xD1,
0x72, 0xC0, 0x17, 0xA5, 0xB8, 0x0A, 0xDD, 0x6F, 0xE7, 0x55, 0x82, 0x30, 0x2D, 0x9F, 0x48, 0xFA,
0x0F, 0xBD, 0x6A, 0xD8, 0xC5, 0x77, 0xA0, 0x12, 0x9A, 0x28, 0xFF, 0x4D, 0x50, 0xE2, 0x35, 0x87,
0x24, 0x96, 0x41, 0xF3, 0xEE, 0x5C, 0x8B, 0x39, 0xB1, 0x03, 0xD4, 0x66, 0x7B, 0xC9, 0x1E, 0xAC,
0xF5, 0x47, 0x90, 0x22, 0x3F, 0x8D, 0x5A, 0xE8, 0x60, 0xD2, 0x05, 0xB7, 0xAA, 0x18, 0xCF, 0x7D,
0xDE, 0x6C, 0xBB, 0x09, 0x14, 0xA6, 0x71, 0xC3, 0x4B, 0xF9, 0x2E, 0x9C, 0x81, 0x33, 0xE4, 0x56,
0xA3, 0x11, 0xC6, 0x74, 0x69, 0xDB, 0x0C, 0xBE, 0x36, 0x84, 0x53, 0xE1, 0xFC, 0x4E, 0x99, 0x2B,
0x88, 0x3A, 0xED, 0x5F, 0x42, 0xF0, 0x27, 0x95, 0x1D, 0xAF, 0x78, 0xCA, 0xD7, 0x65, 0xB2, 0x00,
};
// Look-up table (LUT) for error correction. This LUT maps syndromes to error patterns.
// The LUT is used during decoding to correct errors in the received codeword.
// Each entry corresponds to a syndrome value (0-255) and contains the error pattern
// that should be applied to the data byte to correct it. The syndrome is computed
// as the XOR of the received parity byte and the one derived from the received data byte.
// The LUT is designed for a quasi-cyclic code with 8 data bits and 8 parity bits, and is
// only 8 bits wide as we do not care about correcting the parity bits.
static const uint8_t LUT[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xA0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00,
0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x09, 0x00, 0x10, 0x10, 0x10, 0x40, 0x00, 0x00, 0x10,
0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x10, 0x82, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00,
0x00, 0x80, 0x20, 0x00, 0x20, 0x00, 0x20, 0x20, 0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x20, 0x0C,
0x00, 0x02, 0x00, 0x00, 0x02, 0x02, 0x44, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00,
0x00, 0x00, 0x90, 0x00, 0x00, 0x02, 0x20, 0x00, 0x05, 0x80, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x50, 0x00, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00,
0x00, 0x08, 0x01, 0x84, 0x08, 0x08, 0x00, 0x08, 0x00, 0x11, 0x00, 0x00, 0x24, 0x08, 0x00, 0x00,
0x00, 0x00, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x10, 0x40, 0x40, 0x40, 0x06,
0x01, 0x00, 0x01, 0x01, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x00, 0x18, 0x00,
0x00, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x04, 0x04, 0x88, 0x00, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x03, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x14, 0x00, 0x00, 0x21, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x81, 0x40, 0x00, 0x00, 0x00,
0x0A, 0x00, 0x01, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// data_byte: 8 bits (as uint8_t)
// parity_matrix: 8 rows, each 8 bits (uint8_t[8])
// Returns: 16-bit codeword (8 parity bits | 8 data bits)
uint16_t encode(uint8_t data_byte) {
    const uint16_t codeword = (P[data_byte] << 8) | data_byte;
    return codeword;
}

// codeword: 16 bits (uint16_t)
// Returns: corrected data byte (uint8_t)
uint8_t decode(uint16_t codeword) {
    // Extract the data byte and parity byte from the codeword.
    const uint8_t data_byte = codeword & 0xFF;
    const uint8_t parity_byte = codeword >> 8;
    // Compute syndrome (8 bits).
    const uint8_t syndrome = P[data_byte] ^ parity_byte;

    // Look up error pattern in LUT. The LUT maps syndromes to error patterns, but
    // is only 8 bits as we don't care about correcting the parity bits.
    const uint8_t error_pattern = LUT[syndrome];
    // Correct the data byte by XORing it with the error pattern.
    const uint8_t corrected = data_byte ^ error_pattern;

    // Return the lower 8 bits (data byte)
    return corrected;
}

static int success_count = 0;
static int failure_count = 0;

void test(uint8_t data_byte, uint16_t flipped_bits) {
    const uint16_t encoded = encode(data_byte);
    const uint8_t decoded = decode(encoded ^ flipped_bits); // Introduce bit errors for testing

    if (decoded != data_byte) {
        printf("Failed: Data byte: 0x%02X, Encoded: 0x%04X, Decoded: 0x%02X\n", data_byte, encoded, decoded);
        failure_count++;
    }
    else {
        success_count++; 
    }
}
int main() {
    // Example usage
    printf("Testing Quasi-Cyclic LUT.\n");

    // Count the non-zero entries in the LUT, this corresponds to the number of syndromes that can be corrected.
    int syndrome_count = 0;
    for (int i = 0; i < 256; i++) {
        if (LUT[i] != 0) {
            syndrome_count++;
        }
    }
    if (syndrome_count == 100) {
        printf("LUT has %d non-zero entries, meaning it can correct %d syndromes.\n", syndrome_count, syndrome_count);
    } else {
        printf("LUT has %d non-zero entries, expected 100.\n", syndrome_count);
        return 1; // Exit with error if the LUT is not as expected
    }

    for (uint16_t data_byte = 0; data_byte < 256; data_byte++) {
        test((uint8_t)data_byte, 0);

        for (int i = 0; i < 16; i++) {
            // Test with each single bit flipped
            test((uint8_t)data_byte, (1 << i));
        }

        for (int i = 0; i < 15; i++) {
            for (int j = i+1; j < 16; j++) {
            // Test with each pair of bits flipped
                test((uint8_t)data_byte, (1 << i) | (1 << j) );
            }
        }

    }

    printf("Total successes: %d, Total failures: %d\n", success_count, failure_count);
    if (failure_count > 0)
        return 1;

    return 0;
}